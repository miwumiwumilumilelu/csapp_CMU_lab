Proxy lab要求我们实现一个 HTTP 代理服务器，从而实现在客户端和服务端之间中介的功能。

在这个 lab 中，我们所实现的 HTTP 代理服务器要求至少实现以下功能：
实现代理，通过输入参数获取监听端口号并监听，接受客户端的连接请求，建立连接并转发请求到服务端，同时可以接受服务端的响应并转发到客户端，只要求实现 HTTP GET 方法。
实现并发，即可以同时处理多个客户端的请求。可以选择基于 I/O 多路复用或者多线程（推荐）实现。
实现缓存，即可以缓存服务端的响应，当客户端再次请求时，可以直接从缓存中获取响应并返回给客户端，而不需要再次向服务端请求。缓存替换策略要求实现为 LRU（Least Recently Used，最近最少使用）。


本次实验要求我们由简到繁实现一个代理服务器。压缩包中提供了一个tiny http服务器（之后简称Tiny）的完整代码，Tiny是这次实验的目标服务器，同时其源代码也是我们编写代理服务器时的重要参考。有兴趣的同学可以直接编译出来试一试。对其源代码的解析在书很详细，这里不再赘述。

我们主要修改proxy.c文件中的代码来实现代理服务器。driver.sh脚本可以帮助我们验证编写的正确性。

本次实验分三个部分，循序渐进，逐步实现一个功能完善（勉强算是吧）的代理服务器。三个部分如下：

PART I: Implementing a sequential web proxy：实现一个最基本的顺序代理服务器。除了对请求头必要的处理外，只作为中间人对请求和资源原封不动的转发。不考虑并发情况，也不考虑对资源进行缓存。

Part II: Dealing with multiple concurrent requests：在PART I的基础上，使代理服务器支持并发。writeup文件中推荐使用多线程的方式。

Part III: Caching web objects： 在PART II的基础上，给代理服务器添加一个基础的缓存系统，使其可以存储近期一定量的资源。当客户端请求资源命中缓存时，其可以不用转发请求，直接作为服务器返回资源。

其他的具体细节写在writeup文件中，我会在之后的具体实验中慢慢用到。当然有能力的读者建议阅读完整的writeup文件。
