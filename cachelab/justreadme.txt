-----------------------------------------------------------------
本实验将帮助你理解缓存存储器对C程序性能的影响。
-----------------------------------------------------------------
实验分为两部分。在第一部分中，你将编写一个小的C程序（约200-300行），模拟缓存存储器的行为。在第二部分中，你将优化一个小的矩阵转置函数，目标是尽量减少缓存未命中的次数。
-----------------------------------------------------------------
你将修改两个文件：csim.c和trans.c。要编译这些文件，请输入：
make clean
make
-----------------------------------------------------------------
实验分发包的traces子目录中包含一组参考跟踪文件，我们将使用这些文件来评估你在A部分编写的缓存模拟器的正确性。这些跟踪文件是由一个名为valgrind的Linux程序生成的。例如，在命令行中输入：
valgrind --log-fd=1 --tool=lackey -v --trace-mem=yes ls -l
该命令运行可执行程序“ls -l”，捕获其每次内存访问的跟踪，并按发生顺序将它们打印到stdout

Valgrind内存跟踪的格式如下:
I 0400d7d4,8  #“I”表示指令加载
M 0421c7f0,4  #“M”表示数据修改（即数据加载后跟数据存储）
L 04f6b868,8  #“L”表示数据加载
S 7ff0005c8,8 #“S”表示数据存储
operation address,size
-----------------------------------------------------------------
PartA:	编写缓存模拟器
-----------------------------------------------------------------
在A部分中，你将在csim.c中编写一个缓存模拟器，该模拟器以valgrind内存跟踪作为输入，模拟缓存存储器在该跟踪上的命中/未命中行为，并输出总命中次数、未命中次数和驱逐次数。
-----------------------------------------------------------------
我们为你提供了一个参考缓存模拟器的二进制可执行文件，名为csim-ref，它可以模拟任意大小和关联性的缓存在valgrind跟踪文件上的行为。它在选择要驱逐的缓存行时使用LRU（最近最少使用）替换策略。
参考模拟器接受以下命令行参数：
./csim-ref [-hv] -s <s> -E <E> -b <b> -t <tracefile>

如:
./csim-ref -v -s 4 -E 1 -b 4 -t traces/yi.trace
L 10,1 miss
M 20,1 miss hit
L 22,1 hit
S 18,1 hit
L 110,1 miss eviction
L 210,1 miss eviction
M 12,1 miss eviction hit
hits:4 misses:5 evictions:3

<s,E,b>
-s:组数
-E:每组行数
-b:块数
-v:可选的详细标志，显示跟踪信息
-t:要重放的valgrind跟踪文件的名称
-----------------------------------------------------------------
你在A部分的任务是填充csim.c文件，使其接受相同的命令行参数并生成与参考模拟器相同的输出。请注意，该文件几乎完全为空。你需要从头开始编写它。
-----------------------------------------------------------------
为了获得A部分的学分，你必须在主函数的末尾调用printSummary函数，传入总命中次数、未命中次数和驱逐次数：
printSummary(hit_count, miss_count, eviction_count);
-----------------------------------------------------------------
make && ./test-csim
-----------------------------------------------------------------
PartB:	优化矩阵转置
-----------------------------------------------------------------
在第 B 部分中，您将编写一个转置函数 trans.c，目标是尽可能减少缓存未命中。
-----------------------------------------------------------------
为了帮助您入门，我们在 trans.c 中提供了一个示例转置函数，用于计算 
N×M矩阵A的转置，并将结果存储在M×N矩阵B中：
char trans_desc[] = "简单的逐行扫描转置";
void trans(int M, int N, int A[N][M], int B[M][N])
该示例转置函数是正确的，但由于访问模式导致较多的缓存未命中，因此效率较低。
您在第 B 部分的任务是编写一个类似的函数，名为 transpose_submit，以最小化不同大小矩阵的缓存未命中次数：
char transpose_submit_desc[] = "转置提交";
void transpose_submit(int M, int N, int A[N][M], int B[M][N]);
请勿更改 transpose_submit 函数的描述字符串（"转置提交"）。自动评分器会搜索此字符串以确定要评估的转置函数。
-----------------------------------------------------------------
第 B 部分的编程规则:
在 trans.c 的头部注释中包含您的姓名和登录 ID。
您的 trans.c 代码必须无警告编译才能获得分数。
每个转置函数最多只能定义 12 个 int 类型的局部变量。1
您不能通过使用 long 类型的变量或使用位操作技巧将多个值存储到一个变量中来规避上述规则。
您的转置函数不能使用递归。
如果选择使用辅助函数，您的辅助函数和顶层转置函数的局部变量总数不能超过 12 个。例如，如果您的转置函数声明了 8 个变量，然后调用了一个使用 4 个变量的函数，而该函数又调用了另一个使用 2 个变量的函数，那么栈上将会有 14 个变量，这将违反规则。
您的转置函数不能修改数组A。但是，您可以随意处理数组 B 的内容。
您不允许在代码中定义任何数组或使用任何 malloc 的变体。
-----------------------------------------------------------------
make && ./test-trans -M 32 -N 32
-----------------------------------------------------------------
