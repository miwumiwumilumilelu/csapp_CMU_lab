1.调用函数时，会先把函数返回地址压入栈中，再进入调用的函数
2.getbuf()给栈分配了40个字节的空间,40个之后就是ret存返回地址
3.rsp进入getbuf的时候是0x5561dca0，rsp减40个字节就是0x5561dc78,buf的起始地址即rsp，也就是存getbuf的返回地址,然后跳转到相应地址
栈向下生长，栈顶在低地址，栈底在高地址
指令寄存器（RIP）包含下一条将要被执行的指令的逻辑地址。
通常情况下，每取出一条指令后，RIP会自增指向下一条指令。在x86_64中RIP的自增也即偏移一定字节。（可通过disassemble 查看下一个地址，字节大小不一定等长）
但是RIP并不总是自增，也有例外，例如call 指令和ret指令。call指令会将当前RIP的内容压入栈中，将程序的执行权交给目标函数；ret指令则执行出栈操作，将之前压入栈的8个字节的RIP地址弹出，重新放入RIP。
【缓冲区溢出是如何发生的？】
https://www.bilibili.com/video/BV1R94y1i7tS?vd_source=cfe7f7c1fbfa41212cd730c3b4f666a1
通过看这个视频更容易理解
