 ---------------------------------------------------------------------------
  phase_5解析：
 ---------------------------------------------------------------------------
Dump of assembler code for function phase_5:
   0x0000000000401062 <+0>:     push   %rbx
   0x0000000000401063 <+1>:     sub    $0x20,%rsp
   0x0000000000401067 <+5>:     mov    %rdi,%rbx
   0x000000000040106a <+8>:     mov    %fs:0x28,%rax
   0x0000000000401073 <+17>:    mov    %rax,0x18(%rsp)
   0x0000000000401078 <+22>:    xor    %eax,%eax
   0x000000000040107a <+24>:    call   0x40131b <string_length>
   0x000000000040107f <+29>:    cmp    $0x6,%eax
   0x0000000000401082 <+32>:    je     0x4010d2 <phase_5+112>
   0x0000000000401084 <+34>:    call   0x40143a <explode_bomb>
   0x0000000000401089 <+39>:    jmp    0x4010d2 <phase_5+112>
   0x000000000040108b <+41>:    movzbl (%rbx,%rax,1),%ecx
   0x000000000040108f <+45>:    mov    %cl,(%rsp)
   0x0000000000401092 <+48>:    mov    (%rsp),%rdx
   0x0000000000401096 <+52>:    and    $0xf,%edx
   0x0000000000401099 <+55>:    movzbl 0x4024b0(%rdx),%edx
   0x00000000004010a0 <+62>:    mov    %dl,0x10(%rsp,%rax,1)
   0x00000000004010a4 <+66>:    add    $0x1,%rax
   0x00000000004010a8 <+70>:    cmp    $0x6,%rax
   0x00000000004010ac <+74>:    jne    0x40108b <phase_5+41>
   0x00000000004010ae <+76>:    movb   $0x0,0x16(%rsp)
   0x00000000004010b3 <+81>:    mov    $0x40245e,%esi
   0x00000000004010b8 <+86>:    lea    0x10(%rsp),%rdi
   0x00000000004010bd <+91>:    call   0x401338 <strings_not_equal>
   0x00000000004010c2 <+96>:    test   %eax,%eax
   0x00000000004010c4 <+98>:    je     0x4010d9 <phase_5+119>
   0x00000000004010c6 <+100>:   call   0x40143a <explode_bomb>
   0x00000000004010cb <+105>:   nopl   0x0(%rax,%rax,1)
   0x00000000004010d0 <+110>:   jmp    0x4010d9 <phase_5+119>
   0x00000000004010d2 <+112>:   mov    $0x0,%eax
   0x00000000004010d7 <+117>:   jmp    0x40108b <phase_5+41>
   0x00000000004010d9 <+119>:   mov    0x18(%rsp),%rax
   0x00000000004010de <+124>:   xor    %fs:0x28,%rax
   0x00000000004010e7 <+133>:   je     0x4010ee <phase_5+140>
   0x00000000004010e9 <+135>:   call   0x400b30 <__stack_chk_fail@plt>
   0x00000000004010ee <+140>:   add    $0x20,%rsp                                                                                                                         0x00000000004010f2 <+144>:   pop    %rbx
   0x00000000004010f3 <+145>:   ret
End of assembler dump.
 ---------------------------------------------------------------------------
   0x000000000040107a <+24>:    call   0x40131b <string_length>
   0x000000000040107f <+29>:    cmp    $0x6,%eax
   0x0000000000401082 <+32>:    je     0x4010d2 <phase_5+112>
   0x0000000000401084 <+34>:    call   0x40143a <explode_bomb>
可以看出string_length的返回值为6，那么本题ans是六字符长的字符串
 ---------------------------------------------------------------------------
   0x00000000004010d2 <+112>:   mov    $0x0,%eax
   0x00000000004010d7 <+117>:   jmp    0x40108b <phase_5+41>
eax设置为0后作为迭代条件跳转到循环中，类似for(int i=0;i<6;i++)
 ---------------------------------------------------------------------------
   0x000000000040108b <+41>:    movzbl (%rbx,%rax,1),%ecx
   0x000000000040108f <+45>:    mov    %cl,(%rsp)
   0x0000000000401092 <+48>:    mov    (%rsp),%rdx
   0x0000000000401096 <+52>:    and    $0xf,%edx
   0x0000000000401099 <+55>:    movzbl 0x4024b0(%rdx),%edx
   0x00000000004010a0 <+62>:    mov    %dl,0x10(%rsp,%rax,1)
   0x00000000004010a4 <+66>:    add    $0x1,%rax
   0x00000000004010a8 <+70>:    cmp    $0x6,%rax
ecx=rbx+rax 
通过 x/s $rbx 发现存的是输入ans.txt的字符串,是首字符地址即基地址
还记得之前说的movzbl是取低8位高位补零，所以ecx里存的是一个字符(rax初始为0),后续rax+=1，那么指针移动一位，遍历整个字符串
mov    %cl,(%rsp)
取低rcx低8位(即遍历的字符)存为rsp(栈顶指针)指向值
and    $0xf,%edx
低4位与运算，均为1才为1，记录字符的ASCII码二进制对应的低4位!!!也就是取模16的余数!!!
movzbl 0x4024b0(%rdx),%edx 
通过
x/s 0x4024b0 发现是一串作者的话，答案就在这里面，那么我们此时缺少的是映射成什么(edx)或者是什么将被映射(rdx)
p *(char *)($rdx+0x4024b0) 可以查看存的字符的映射值
mov    %dl,0x10(%rsp,%rax,1)
将低8位即存的一个字符放到栈顶+0x16(固定偏移量)（作为新的基地址)往后
 ---------------------------------------------------------------------------
   0x00000000004010ae <+76>:    movb   $0x0,0x16(%rsp)
   0x00000000004010b3 <+81>:    mov    $0x40245e,%esi
   0x00000000004010b8 <+86>:    lea    0x10(%rsp),%rdi
   0x00000000004010bd <+91>:    call   0x401338 <strings_not_equal>
   0x00000000004010c2 <+96>:    test   %eax,%eax
   0x00000000004010c4 <+98>:    je     0x4010d9 <phase_5+119>
   0x00000000004010c6 <+100>:   call   0x40143a <explode_bomb>
那么需要满足跳转条件，eax=0，说明<string_not_equal>函数中两个函数相等，发现rdi存的是映射后的字符串作为第一参数，rsi存第二参数是固定值
通过x/s 0x40245e 查看是"flyers"对应映射后的函数
在刚才查看的作者话中有出现："maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?"
f:0x40245e + 9
l: + 15
y: + 14
e: + 5
r: + 6
s: + 7
可以我们输入ans每个字符对应ASCII取模16的余数以此是9 15 14 5 6 7
查表可知a ASCII为97=96+1 A 为65=
96+9 : i
96+15 : o
96+14 : n
96+5 : e
96+6 : f
96+7: g
or
64+9 : I
同理 IONEFG
那么这题也是多解题：
我猜测除了这两组还可以是ASCII上满足16k+(相应余数)的关于k的一组解都行
 ---------------------------------------------------------------------------
   0x000000000040106a <+8>:     mov    %fs:0x28,%rax : %fs 是一个段寄存器,%fs:0x28 表示从 %fs 段基址偏移 0x28（即 40 字节）的位置读取数据。通常用于存储栈保护值（Stack Canary），用于防止栈溢出攻击
   0x0000000000401078 <+22>:    xor    %eax,%eax : 表示将 %eax 寄存器的值与自身进行异或操作
 ---------------------------------------------------------------------------return expr << 23 | frac;
