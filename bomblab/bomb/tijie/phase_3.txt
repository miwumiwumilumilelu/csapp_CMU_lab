---------------------------------------------------------------------------
  phase_3解析：
---------------------------------------------------------------------------
Dump of assembler code for function phase_3:
   0x0000000000400f43 <+0>:     sub    $0x18,%rsp
   0x0000000000400f47 <+4>:     lea    0xc(%rsp),%rcx
   0x0000000000400f4c <+9>:     lea    0x8(%rsp),%rdx
   0x0000000000400f51 <+14>:    mov    $0x4025cf,%esi
   0x0000000000400f56 <+19>:    mov    $0x0,%eax
   0x0000000000400f5b <+24>:    call   0x400bf0 <__isoc99_sscanf@plt>
   0x0000000000400f60 <+29>:    cmp    $0x1,%eax
   0x0000000000400f63 <+32>:    jg     0x400f6a <phase_3+39>
   0x0000000000400f65 <+34>:    call   0x40143a <explode_bomb>
   0x0000000000400f6a <+39>:    cmpl   $0x7,0x8(%rsp)
   0x0000000000400f6f <+44>:    ja     0x400fad <phase_3+106>
   0x0000000000400f71 <+46>:    mov    0x8(%rsp),%eax
   0x0000000000400f75 <+50>:    jmp    *0x402470(,%rax,8)
   0x0000000000400f7c <+57>:    mov    $0xcf,%eax
   0x0000000000400f81 <+62>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f83 <+64>:    mov    $0x2c3,%eax
   0x0000000000400f88 <+69>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f8a <+71>:    mov    $0x100,%eax
   0x0000000000400f8f <+76>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f91 <+78>:    mov    $0x185,%eax
   0x0000000000400f96 <+83>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f98 <+85>:    mov    $0xce,%eax
   0x0000000000400f9d <+90>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f9f <+92>:    mov    $0x2aa,%eax
   0x0000000000400fa4 <+97>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400fa6 <+99>:    mov    $0x147,%eax
   0x0000000000400fab <+104>:   jmp    0x400fbe <phase_3+123>
   0x0000000000400fad <+106>:   call   0x40143a <explode_bomb>
   0x0000000000400fb2 <+111>:   mov    $0x0,%eax
   0x0000000000400fb7 <+116>:   jmp    0x400fbe <phase_3+123>
   0x0000000000400fb9 <+118>:   mov    $0x137,%eax
   0x0000000000400fbe <+123>:   cmp    0xc(%rsp),%eax
   0x0000000000400fc2 <+127>:   je     0x400fc9 <phase_3+134>
   0x0000000000400fc4 <+129>:   call   0x40143a <explode_bomb>
   0x0000000000400fc9 <+134>:   add    $0x18,%rsp
   0x0000000000400fcd <+138>:   ret
End of assembler dump.
---------------------------------------------------------------------------
调试题，stepi从上往下调试即可
首先在main中找到phase_3的断点处 
b 89
一直stepi进入函数中,finish完成函数返回，发现函数传参是两个整形数，也就是需要输入的（也就是需要求的答案）
此时随便输入两个答案到ans.txt中,再
r ans.txt
---------------------------------------------------------------------------
再往后跳转发现
   0x0000000000400f6a <+39>:    cmpl   $0x7,0x8(%rsp)
   0x0000000000400f6f <+44>:    ja     0x400fad <phase_3+106>
   0x0000000000400fad <+106>:   call   0x40143a <explode_bomb>
发现($rsp+0x8)<0x7
又
p *(int *)($rsp+0x8) 发现这个值就是我们输入的第一个参数,所以修改第一个参数使其小于7再
r ans.txt
---------------------------------------------------------------------------
在这之前为了快捷修改断点为 b *0x0000000000400f75
   0x0000000000400f75 <+50>:    jmp    *0x402470(,%rax,8)
这个不用计算直接调试stepi进行跳转后
通过
x/5i $pc 进行查看跳转到哪里了
---------------------------------------------------------------------------
以第一个参数为6为例，上一个指令则跳转到了
   0x0000000000400f9f <+92>:    mov    $0x2aa,%eax
   0x0000000000400fa4 <+97>:    jmp    0x400fbe <phase_3+123>
通过
p 0x2aa
打印保存到%eax中的值
---------------------------------------------------------------------------
   0x0000000000400fbe <+123>:   cmp    0xc(%rsp),%eax
   0x0000000000400fc2 <+127>:   je     0x400fc9 <phase_3+134>
   0x0000000000400fc4 <+129>:   call   0x40143a <explode_bomb>
   0x0000000000400fc9 <+134>:   add    $0x18,%rsp
   0x0000000000400fcd <+138>:   ret
此时打印0xc(%rsp)
p *(int *)($rsp+0xc) 发现为第二个参数，则将其修改与%eax存的值相等即可
 ---------------------------------------------------------------------------
我只做了6 682 和 5 206
可以发现一共有8组mov xxx,%eax  jmp
容易知道有8组答案，类似于switch :有 0 1 2 3 4 5 6 7 (<=7,与ja刚好相反)
 ---------------------------------------------------------------------------
   0x0000000000400f60 <+29>:    cmp    $0x1,%eax
   0x0000000000400f63 <+32>:    jg     0x400f6a <phase_3+39>
   0x0000000000400f65 <+34>:    call   0x40143a <explode_bomb>
对于函数返回值大于1即可，通过调试finish后可以看到如果大于1那么正确
ja与jg跳转指令的区别:ja是无符号数 (地址，计数器)，jg是有符号数（正负数）
x/5i $pc :  $pc 是 GDB 中表示 程序计数器（Program Counter）的寄存器，它指向当前正在执行的指令的地址。i 表示以 指令（instruction） 的形式显示内存内容。/5 表示显示 5 个单位的内容。
 ---------------------------------------------------------------------------return expr << 23 | frac;
