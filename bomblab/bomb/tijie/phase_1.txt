---------------------------------------------------------------------
汇编函数 strings_not_equal 分析
---------------------------------------------------------------------
Dump of assembler code for function strings_not_equal:
   0x0000000000401338 <+0>:     push   %r12
   0x000000000040133a <+2>:     push   %rbp
   0x000000000040133b <+3>:     push   %rbx
   0x000000000040133c <+4>:     mov    %rdi,%rbx
   0x000000000040133f <+7>:     mov    %rsi,%rbp
   0x0000000000401342 <+10>:    call   0x40131b <string_length>
   0x0000000000401347 <+15>:    mov    %eax,%r12d
   0x000000000040134a <+18>:    mov    %rbp,%rdi
   0x000000000040134d <+21>:    call   0x40131b <string_length>
   0x0000000000401352 <+26>:    mov    $0x1,%edx
   0x0000000000401357 <+31>:    cmp    %eax,%r12d
   0x000000000040135a <+34>:    jne    0x40139b <strings_not_equal+99>
   0x000000000040135c <+36>:    movzbl (%rbx),%eax
   0x000000000040135f <+39>:    test   %al,%al
   0x0000000000401361 <+41>:    je     0x401388 <strings_not_equal+80>
   0x0000000000401363 <+43>:    cmp    0x0(%rbp),%al
   0x0000000000401366 <+46>:    je     0x401372 <strings_not_equal+58>
   0x0000000000401368 <+48>:    jmp    0x40138f <strings_not_equal+87>
   0x000000000040136a <+50>:    cmp    0x0(%rbp),%al
   0x000000000040136d <+53>:    nopl   (%rax)
   0x0000000000401370 <+56>:    jne    0x401396 <strings_not_equal+94>
   0x0000000000401372 <+58>:    add    $0x1,%rbx
   0x0000000000401376 <+62>:    add    $0x1,%rbp
   0x000000000040137a <+66>:    movzbl (%rbx),%eax
   0x000000000040137d <+69>:    test   %al,%al
   0x000000000040137f <+71>:    jne    0x40136a <strings_not_equal+50>
   0x0000000000401381 <+73>:    mov    $0x0,%edx
   0x0000000000401386 <+78>:    jmp    0x40139b <strings_not_equal+99>
   0x0000000000401388 <+80>:    mov    $0x0,%edx
   0x000000000040138d <+85>:    jmp    0x40139b <strings_not_equal+99>
   0x000000000040138f <+87>:    mov    $0x1,%edx
   0x0000000000401394 <+92>:    jmp    0x40139b <strings_not_equal+99>
   0x0000000000401396 <+94>:    mov    $0x1,%edx
   0x000000000040139b <+99>:    mov    %edx,%eax
   0x000000000040139d <+101>:   pop    %rbx
   0x000000000040139e <+102>:   pop    %rbp
   0x000000000040139f <+103>:   pop    %r12
   0x00000000004013a1 <+105>:   ret
---------------------------------------------------------------------
该函数用于比较两个字符串是否不相等。若字符串长度不同或内容不同，返回 1（不相等）；否则返回 0（相等）。
---------------------------------------------------------------------
0x0000000000101338 <+0>: push %r12
0x000000000010133a <+2>: push %rbp
0x000000000010133b <+3>: push %rbx
是将这三个寄存器的值压入栈中，是为了保存调用者的寄存器状态
---------------------------------------------------------------------
%rdi存第一个参数，%rsi存第二个参数，即第一第二字符串
0x000000000010133c <+4>: mov %rdi,%rbx   // 第一个字符串指针存入 %rbx
0x000000000010133f <+7>: mov %rsi,%rbp   //第二个字符串指针存入 %rbp
%rbx，%rbp将用于遍历字符串，采用(%rbx)的方式取字符串指针指向地址的值，后续会讲到movzbl的搭配用法
---------------------------------------------------------------------
0x0000000000101342 <+10>: call 0x40131b <string_length> 
0x0000000000101347 <+15>: mov %eax,%r12d               
0x000000000010134a <+18>: mov %rbp,%rdi   
0x000000000010134d <+21>: call 0x40131b <string_length>
函数返回值存在%eax中,%rdi则用来传参给函数，%eax中值会被函数调用后覆盖，不用管，而%rdi的值需要先替换再传入，所以将第二个字符地址传到%rdi中，作为下一个函数调用的第一参数,调用后的值存入%eax
0x0000000000101352 <+26>: mov $0x1,%edx    
0x0000000000101357 <+31>: cmp %eax,%r12d    //比较两个长度
0x000000000010135a <+34>: jne 0x40139b      //长度不等则跳转到结尾:ret,因为已经设置初始值1了，就是不相等函数返回1就行了，所以直接跳转到ret
cmp a,b  <=> b-a ,然后根据结果设置标志来作为条件进行后续跳转
默认返回值1存在%edx中类似于初始化值为1，如果长度不等则就返回1了
---------------------------------------------------------------------
比较完长度(整体)，逐个比较字符：
以下类似于循环遍历字符判断的中止条件：
0x000000000010135c <+36>: movzbl (%rbx),%eax   //加载第一个字符到 %eax
0x000000000010135f <+39>: test %al,%al         //检查是否为 '\0'(函数结束标志)
0x0000000000101361 <+41>: je 0x401388          //是则跳转到返回 0
test是位操作运算，是&与运算，test %al,%al检查%al中值是否为0，如果为0，则zf=0表示结果真，否则zf=1 用于条件跳转
test %al,%al 为0说明两字符串都有'\0'结尾且长度相同，返回0
---------------------------------------------------------------------、
0x0000000000101363 <+43>: cmp 0x0(%rbp),%al    //比较两个字符
0x0000000000101366 <+46>: je 0x401372          //相等则继续
0x0000000000101368 <+48>: jmp 0x40138f         //不等则返回 1
0x0(%rbp)虽然偏移量为0，但有助于代码清晰
---------------------------------------------------------------------
继续比较：
0x0000000000101372 <+58>: add $0x1,%rbx  
0x0000000000101376 <+62>: add $0x1,%rbp  
0x000000000010137a <+66>: movzbl (%rbx),%eax   
0x000000000010137d <+69>: test %al,%al       
0x000000000010137f <+71>: jne 0x40136a         // 若非 0，继续比较
因为每个字符占1字节，指针只需移动1字节即可访问下一个字符
movzbl (%rbx),%eax ：更新到%eax中进行覆盖
---------------------------------------------------------------------
函数返回与恢复寄存器
0x000000000010139b <+99>: mov %edx,%eax        
0x000000000010139d <+101>: pop %rbx            
0x000000000010139e <+102>: pop %rbp
0x000000000010139f <+103>: pop %r12
0x00000000001013a1 <+105>: ret                 
---------------------------------------------------------------------
在x86-64中%eax是%rax的低32位,%al是%rax的低8位,1B=8bit，而一个字符占一个字节，即char
movzbl: movb传送一个字节(mov B) , "z"表示零扩展(zero), "l"表示扩展到32位(long) ，long 4个字节，零扩展为高位填充 零扩展确保高24位为0，避免残留垃圾值
0x0(%rbp):表示0x0+%rbx中的内存地址   参考九曲阑干的立即数那一节，如:0x1(%rdi,%rdi,4)表示0x1+%rdi+%rdi*4  内存地址 = 基址寄存器 + 索引寄存器 * 缩放因子 + 偏移量
---------------------------------------------------------------------

