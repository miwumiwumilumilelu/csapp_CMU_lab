 ---------------------------------------------------------------------------
phase_4解析：主要是其中的func4函数
---------------------------------------------------------------------------
ans是两个数，这个通过stepi就能发现，phase_3讲过，不赘述
 ---------------------------------------------------------------------------
   0x000000000040103a <+46>:    mov    $0xe,%edx
   0x000000000040103f <+51>:    mov    $0x0,%esi
   0x0000000000401044 <+56>:    mov    0x8(%rsp),%edi
   0x0000000000401048 <+60>:    call   0x400fce <func4>
   0x000000000040104d <+65>:    test   %eax,%eax
   0x000000000040104f <+67>:    jne    0x401058 <phase_4+76>
phase_4+76炸弹爆炸，所以需要eax为0，满足相等条件不会跳转
edx=14,esi=0,edi=第一个输入值  作为参数传入func4
 ---------------------------------------------------------------------------
接下来看<func4>:
   0x0000000000400fce <+0>:     sub    $0x8,%rsp
   0x0000000000400fd2 <+4>:     mov    %edx,%eax
   0x0000000000400fd4 <+6>:     sub    %esi,%eax
   0x0000000000400fd6 <+8>:     mov    %eax,%ecx
   0x0000000000400fd8 <+10>:    shr    $0x1f,%ecx
   0x0000000000400fdb <+13>:    add    %ecx,%eax
   0x0000000000400fdd <+15>:    sar    %eax
   0x0000000000400fdf <+17>:    lea    (%rax,%rsi,1),%ecx
   0x0000000000400fe2 <+20>:    cmp    %edi,%ecx
   0x0000000000400fe4 <+22>:    jle    0x400ff2 <func4+36>
   0x0000000000400fe6 <+24>:    lea    -0x1(%rcx),%edx
   0x0000000000400fe9 <+27>:    call   0x400fce <func4>
   0x0000000000400fee <+32>:    add    %eax,%eax
   0x0000000000400ff0 <+34>:    jmp    0x401007 <func4+57>
   0x0000000000400ff2 <+36>:    mov    $0x0,%eax
   0x0000000000400ff7 <+41>:    cmp    %edi,%ecx
   0x0000000000400ff9 <+43>:    jge    0x401007 <func4+57>
   0x0000000000400ffb <+45>:    lea    0x1(%rcx),%esi
   0x0000000000400ffe <+48>:    call   0x400fce <func4>
   0x0000000000401003 <+53>:    lea    0x1(%rax,%rax,1),%eax
   0x0000000000401007 <+57>:    add    $0x8,%rsp
   0x000000000040100b <+61>:    ret
 ---------------------------------------------------------------------------
随便两个数字,rdi是第一个输入值，本函数也只与第一个输入值有关，因为先前跳转条件是<=14，所以我取了14
   0x0000000000400fce <+0>:     sub    $0x8,%rsp
   0x0000000000400fd2 <+4>:     mov    %edx,%eax
   0x0000000000400fd4 <+6>:     sub    %esi,%eax
   0x0000000000400fd6 <+8>:     mov    %eax,%ecx
   0x0000000000400fd8 <+10>:    shr    $0x1f,%ecx
   0x0000000000400fdb <+13>:    add    %ecx,%eax
   0x0000000000400fdd <+15>:    sar    %eax
   0x0000000000400fdf <+17>:    lea    (%rax,%rsi,1),%ecx
   0x0000000000400fe2 <+20>:    cmp    %edi,%ecx
edi是我输入的值没有变化，因为前面变化的都是edx，esi，ecx相关，发现此时ecx固定为7，edi为14  -7<0跳转到mov 0x0,%eax是我想要的结果
   0x0000000000400fe4 <+22>:    jle    0x400ff2 <func4+36>
   0x0000000000400ff2 <+36>:    mov    $0x0,%eax
   0x0000000000400ff7 <+41>:    cmp    %edi,%ecx
   0x0000000000400ff9 <+43>:    jge    0x401007 <func4+57>
此时又再次重复刚才的比较，而且相反不会跳转到结束，后续会有eax被覆盖，所以没办法保证答案为0
发现！第一次比较是<=,第二次是>=，因此为了都跳转，一轮func4直接跳出函数那么就需要两次都相等，即edi=ecx=7，所以改了第一个输入值为7就是其中一个正确解
 ---------------------------------------------------------------------------
后来又试了0，1，2发现0，1可以，2不行，激起了我的战斗欲
func4本质:
 ---------------------------------------------------------------------------
通过
layout asm   layout regs 的辅助
发现！每次func4调用都会二分一下，然后edx会在二分的基础上再减一成偶数，为下一次二分即func4的调用做准备
mid = (edx - esi) / 2！！！
edx为上限，esi为下限，一次二分后，edx-=1
如果edi==其中一次mid时就可以返回edx=0
 ---------------------------------------------------------------------------
（14-0）/2=7
（6-0）/2=3
（2-0）/2=1
（0-0）/2=0
故正确的ans有7 ， 3 ， 1 ，0
shr luojiyouyi  sar suanshuyouyi	
 ---------------------------------------------------------------------------
