# CS 213，2001年秋季
## 内存分配实验室：编写动态存储分配器
**布置时间**：11月2日，星期五  
**截止时间**：11月20日，星期二，晚上11:59  
**负责人**：Cory Williams (cgw@andrew.cmu.edu)

## 1 引言
在这个实验中，你将为C程序编写一个动态存储分配器，即你自己的`malloc`、`free`和`realloc`函数版本。我们鼓励你发挥创意，探索设计空间，实现一个正确、高效且快速的分配器。

## 2 后勤安排
你可以与最多一人组成小组完成此任务。关于本作业的任何澄清和修订将在课程网页上发布。

## 3 发放说明
**特定于站点的说明**：在此处插入一段说明，解释学生应如何下载`malloclab-handout.tar`文件。

首先将`malloclab-handout.tar`复制到你计划用于工作的受保护目录中。然后执行命令：`tar xvf malloclab-handout.tar`。这将解压多个文件到该目录中。你需要修改并提交的唯一文件是`mm.c`。`mdriver.c`程序是一个驱动程序，允许你评估你的解决方案的性能。使用命令`make`生成驱动代码，并使用命令`./mdriver -V`运行它。（`-V`标志显示有用的摘要信息。）

查看`mm.c`文件时，你会注意到一个名为`team`的C结构体，你应该立即在其中插入有关你的编程团队（一人或两人）的所需识别信息，以免忘记。

完成实验后，你只需提交一个文件（`mm.c`），其中包含你的解决方案。

## 4 如何进行实验
你的动态存储分配器将包含以下四个函数，这些函数在`mm.h`中声明并在`mm.c`中定义：
• `int mm_init(void);`
• `void *mm_malloc(size_t size);`
• `void mm_free(void *ptr);`
• `void *mm_realloc(void *ptr, size_t size);`

我们提供的`mm.c`文件实现了一个最简单但功能正确的malloc包。以此为基础，修改这些函数（并可能定义其他私有静态函数），使其遵循以下语义：

### `mm_init`
在调用`mm_malloc`、`mm_realloc`或`mm_free`之前，应用程序（即用于评估你的实现的跟踪驱动程序）调用`mm_init`执行任何必要的初始化，例如分配初始堆区域。如果初始化成功，返回0；否则返回-1。

### `mm_malloc`
`mm_malloc`函数返回一个指向至少`size`字节大小的已分配块有效载荷的指针。整个已分配块应位于堆区域内，并且不应与任何其他已分配块重叠。

我们将把你的实现与标准C库（libc）提供的`malloc`版本进行比较。由于libc的`malloc`总是返回按8字节对齐的有效载荷指针，你的`malloc`实现也应如此，始终返回按8字节对齐的指针。

### `mm_free`
`mm_free`函数释放由`ptr`指向的块。它不返回任何值。此函数仅在传递的指针（`ptr`）是由先前的`mm_malloc`或`mm_realloc`调用返回且尚未被释放时才保证有效。

### `mm_realloc`
`mm_realloc`函数返回一个指向至少`size`字节大小的已分配区域的指针，并满足以下约束条件：
• 如果`ptr`为`NULL`，则调用等同于`mm_malloc(size)`；
• 如果`size`等于零，则调用等同于`mm_free(ptr)`；
• 如果`ptr`不为`NULL`，它必须是由先前的`mm_malloc`或`mm_realloc`调用返回的。

对`mm_realloc`的调用会改变由`ptr`指向的旧块的大小为`size`字节，并返回新块的地址。请注意，新块的地址可能与旧块相同，也可能不同，这取决于你的实现、旧块中的内部碎片量以及`realloc`请求的大小。

新块的内容与前一个`ptr`块的内容相同，直到旧块和新块大小的最小值。其余部分未初始化。例如，如果旧块为8字节，新块为12字节，则新块的前8字节与旧块的前8字节相同，后4字节未初始化。类似地，如果旧块为8字节，新块为4字节，则新块的内容与前4字节旧块的内容相同。

这些语义与libc的`malloc`、`realloc`和`free`函数的相应语义相匹配。输入`man malloc`到shell以获取完整文档。

## 5 堆一致性检查器
动态内存分配器在正确高效地编程方面非常棘手。它们难以正确编程，因为它们涉及大量未类型化的指针操作。你可能会发现编写一个堆检查器非常有帮助，它可以扫描堆并检查其一致性。

堆检查器可能检查的一些示例包括：
• 每个空闲列表中的块是否都标记为空闲？
• 是否有任何连续的空闲块未被合并？
• 每个空闲块是否确实在空闲列表中？
• 空闲列表中的指针是否指向有效的空闲块？
• 任何已分配块是否重叠？
• 堆块中的指针是否指向有效的堆地址？

你的堆检查器将由`mm.c`中的`int mm_check(void)`函数组成。它将检查你认为谨慎的任何不变量或一致性条件。当且仅当堆一致时，它返回非零值。在开发过程中，你可能会发现打印出`mm_check`失败时的错误消息很有帮助。提交`mm.c`时，请确保删除对`mm_check`的任何调用，因为它们会降低你的吞吐量。对于你的`mm_check`函数，将给予风格分。确保添加注释并记录你在检查的内容。

## 6 支持例程
`memlib.c`包模拟了你的动态内存分配器的内存系统。你可以在`memlib.c`中调用以下函数：
• `void *mem_sbrk(int incr);`：按`incr`字节扩展堆，其中`incr`是一个正的非零整数，并返回指向新分配堆区域第一个字节的通用指针。语义与Unix的`sbrk`函数相同，只是`mem_sbrk`只接受正的非零整数参数。
• `void *mem_heap_lo(void);`：返回指向堆中第一个字节的通用指针。
• `void *mem_heap_hi(void);`：返回指向堆中最后一个字节的通用指针。
• `size_t mem_heapsize(void);`：返回当前堆的大小（以字节为单位）。
• `size_t mem_pagesize(void);`：返回系统的页面大小（在Linux系统上为4K）。

## 7 跟踪驱动程序
驱动程序`mdriver.c`在`malloclab-handout.tar`分发中测试你的`mm.c`包的正确性、空间利用率和吞吐量。驱动程序由一组跟踪文件控制，这些文件也包含在`malloclab-handout.tar`分发中。每个跟踪文件包含一系列分配、重新分配和释放指令，指示驱动程序按某种顺序调用你的`mm_malloc`、`mm_realloc`和`mm_free`函数。驱动程序和跟踪文件与我们用于评分你提交的`mm.c`文件的相同。

驱动程序`mdriver.c`接受以下命令行参数：
• `-t <tracedir>`：在`tracedir`目录中查找默认跟踪文件，而不是在`config.h`中定义的默认目录。
• `-f <tracefile>`：使用特定的跟踪文件进行测试，而不是默认的跟踪文件集。
• `-h`：打印命令行参数的摘要。
• `-l`：运行并测量libc的`malloc`以及学生的`malloc`包。
• `-v`：详细输出。为每个跟踪文件打印性能分解的紧凑表格。
• `-V`：更详细的输出。处理每个跟踪文件时打印额外的诊断信息。这在调试时非常有用，可以帮助你确定哪个跟踪文件导致你的`malloc`包失败。

## 8 编程规则
• 你不应该更改`mm.c`中的任何接口。
• 你不应该调用任何与内存管理相关的库调用或系统调用。这排除了在你的代码中使用`malloc`、`calloc`、`free`、`realloc`、`sbrk`、`brk`或这些调用的任何变体。
• 在你的`mm.c`程序中，你不允许定义任何全局或静态复合数据结构，如数组、结构体、树或列表。但是，你可以在`mm.c`中声明全局标量变量，如整数、浮点数和指针。
• 为了与libc的`malloc`包保持一致，后者返回按8字节对齐的块，你的分配器必须始终返回按8字节对齐的指针。驱动程序将强制执行此要求。

## 9 评估
如果你违反任何规则或代码有错误并导致驱动程序崩溃，你将得零分。否则，你的成绩将按以下方式计算：
• **正确性**（20分）：如果你的解决方案通过了驱动程序执行的正确性测试，你将获得满分。每个正确的跟踪文件都会获得部分分数。
• **性能**（35分）：将使用两个性能指标来评估你的解决方案：
  • **空间利用率**：驱动程序分配的堆内存总量（通过`mm_malloc`或`mm_realloc`分配但尚未通过`mm_free`释放）与你的分配器使用的堆大小的峰值比率。最优比率为1。你应该找到良好的策略来最小化碎片，使这个比率尽可能接近最优值。
  • **吞吐量**：每秒完成的平均操作数。
  
  驱动程序通过计算性能指数`P`来总结你的分配器的性能，这是一个加权的空间利用率和吞吐量之和：
  $$
  P = wU + (1 - w) \cdot \min\left(1, \frac{T}{T_{\text{libc}}}\right)
$$
  其中`U`是你的空间利用率，`T`是你的吞吐量，`T_{\text{libc}}`是驱动程序在你的系统上针对默认跟踪文件估计的libc `malloc`的吞吐量。性能指数倾向于空间利用率高于吞吐量，默认权重`w = 0.6`。

  观察到内存和CPU周期都是昂贵的系统资源，我们采用这个公式来鼓励对内存利用率和吞吐量进行平衡优化。理想情况下，性能指数将达到`P = w + (1 - w) = 1`或100%。由于每个指标最多分别贡献`w`和`1 - w`到性能指数，你不应该极端地优化空间利用率或吞吐量中的任何一个。为了获得好成绩，你必须在利用率和吞吐量之间取得平衡。

• **风格**（10分）：
  • 你的代码应该分解成函数，并尽可能少地使用全局变量。
  • 你的代码应该以描述堆中空闲和已分配块的结构、空闲列表的组织方式以及你的分配器如何操作空闲列表的头注释开始。每个函数之前都应该有一个描述其功能的头注释。
  • 每个子程序都应该有一个描述其功能和实现方式的头注释。
  • 你的堆一致性检查器`mm_check`应该全面且文档齐全。

  你将因良好的堆一致性检查器获得5分，因良好的程序结构和注释获得5分。

## 10 提交说明
**特定于站点的说明**：在此处插入一段说明，解释学生应如何提交他们的解决方案文件`mm.c`。

## 11 提示
• 使用`mdriver -f`选项。在初期开发期间，使用小型跟踪文件将简化调试和测试。我们包含了两个这样的跟踪文件（`short1`和`short2-bal.rep`），你可以用于初步调试。
• 使用`mdriver -v`和`-V`选项。`-v`选项将为每个跟踪文件提供详细的摘要。`-V`还会指示何时读取每个跟踪文件，这将帮助你隔离错误。
• 使用`gcc -g`编译并使用调试器。调试器将帮助你隔离和识别越界内存引用。
• 理解教科书中的每个malloc实现细节。教科书提供了一个基于隐式空闲列表的简单分配器的详细示例。以此为出发点。在开始编写自己的分配器之前，请确保你完全理解了简单的隐式列表分配器。
• 封装你的指针算术操作到C预处理器宏中。内存管理中的指针算术容易混淆且容易出错，因为需要大量的类型转换。通过为你的指针操作编写宏，可以显著降低复杂性。参见教科书中的示例。
• 分阶段实现。前9个跟踪文件只包含`malloc`和`free`请求。我们建议先让你的`malloc`和`free`函数在处理前9个跟踪文件时正确且高效地工作。然后，再考虑`realloc`的实现。为了获得良好的性能，你可能需要构建一个独立的`realloc`函数。但要获得真正优秀的性能，你需要构建一个独立的`realloc`。
• 使用性能分析工具。你可能会发现`gprof`工具对优化性能有帮助。
• 尽早开始！编写一个高效的malloc包可以用几页代码完成。然而，我们可以保证这是你迄今为止在职业生涯中编写的最困难和最复杂的代码之一。所以尽早开始，祝你好运！
