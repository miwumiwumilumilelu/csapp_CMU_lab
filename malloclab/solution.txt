--------------------------------------------------------
Malloc Lab 要求实现一个动态内存分配器，
需要实现 malloc，free 和 realloc 函数，
目标是正确、利用率高且高效。
--------------------------------------------------------
Utilization(空间利用率)，为malloc与realloc分配且未被free的内存与当前堆内存的大小的比值。即浪费的内存越少越好。
Throughput(吞吐量)，单位时间内完成的平均请求数。即时间复杂度要尽量小。
--------------------------------------------------------
需要管理的堆内存是一块连续的区域。分配器将这块区域分配成很多块来管理，
每个块的大小不一定相同，并且有一些在被使用中，或者已经free掉，
但是相邻两个块如果都是free的，那么会需要把它们合并起来，合并的策略也不一样，
这里简单用立即合并，即free掉某个块后，发现旁边有free的块，就合并
--------------------------------------------------------
malloc的函数定义是void* malloc(size_t size)
拿出一个比size更大的块，返回给用户该块的地址，这个块之后就不能再分配给其它人了。
--------------------------------------------------------
free的函数定义是void free(void* p)
free只给定了一个指针，我们需要知道到底需要释放多少内存，即给出去的指针里，我们需要从这上面能得知分配的大小等信息。
所以我们可以把完整的块定义成这样:
header block_size footer
--------------------------------------------------------
看九曲阑干直播课:

/* 基础宏*/

#define WSIZE 4 // 字长4字节，块头尾信息也为4字节
#define DSIZE 8
#define CHUNKSIZZE (1 << 12) // 堆初始化大小 4KB 正好是页大小
​
#define MAX(x, y) ((x) > (y)) ? (x) : (y)
/* 把块大小和信息位结合*/
#define PACK(size, alloc) ((size) | (alloc))
/* 在地址p处读写 */
#define GET(p) (*(unsigned int *)(p))
#define PUT(p, val) (*(unsigned int *)(p) = (val))
​
/* 从头部或脚部 获取块大小和信息位的值 */
#define GET_SIZE(p) (GET(p) & ~0x07)
#define GET_ALLOC(p) (GET(p) & 0x1)
​
/*给定块指针bp，其指向有效载荷，计算头部和尾部指针*/
#define HDRP(bp) ((char *)(bp) - WSIZE)
#define FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)
​
/* 给定块指针bp, 计算先前块和后面块的地址 */
#define NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE((char *)(bp) - WSIZE))
#define PREV_BLKP(bp) ((char *)(bp) - GET_SIZE((char *)(bp) - DSIZE))
--------------------------------------------------------

--------------------------------------------------------
./mdriver -V -f short1-bal.rep
进行案例测试:
--------------------------------------------------------
