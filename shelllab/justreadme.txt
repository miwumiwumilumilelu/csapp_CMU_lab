------------------------------------------------------------------------
shelllab:
------------------------------------------------------------------------
本作业的目的是让你更加熟悉进程控制和信号处理的概念。你将通过编写一个支持作业控制的简单 Unix shell 程序来实现这一目标。
------------------------------------------------------------------------
tar xvf shlab-handout.tar
make
查看 tsh.c（tiny shell）文件，你会发现它包含一个简单 Unix shell 的功能框架。为了帮助你入门，我们已经实现了其中不太有趣的部分函数。你的任务是完成下面列出的剩余空函数。为了让你有一个参考，我们列出了每个函数在我们参考解决方案中的大致代码行数（包括大量注释）。
eval：解析和解释命令行的主要例程。[70行]
builtin_cmd：识别并解释内置命令：quit、fg、bg 和 jobs。[25行]
do_bgfg：实现 bg 和 fg 内置命令。[50行]
waitfg：等待前台作业完成。[20行]
sigchild_handler：捕获 SIGCHILD 信号。[80行]
sigint_handler：捕获 SIGINT（ctrl-c）信号。[15行]
sigtstp_handler：捕获 SIGTSTP（ctrl-z）信号。[15行]
------------------------------------------------------------------------
每次修改 tsh.c 文件后，输入 make 重新编译。要运行你的 shell，输入 tsh 到命令行：
unix> ./tsh
tsh> [_在此处输入命令到你的 shell_]
------------------------------------------------------------------------
Unix Shell 的概述
Shell 是一个交互式命令行解释器，代表用户运行程序。Shell 会重复打印提示符，等待标准输入中的命令行，然后根据命令行的内容执行某些操作。

命令行是由空格分隔的 ASCII 文本单词序列。命令行中的第一个单词要么是内置命令的名称，要么是可执行文件的路径名。其余单词是命令行参数。如果第一个单词是内置命令，shell 会立即在当前进程中执行该命令。否则，该单词被假定为可执行程序的路径名。在这种情况下，shell 会 fork 一个子进程，然后在子进程的上下文中加载并运行该程序。由于解释单个命令行而创建的子进程统称为作业。通常，一个作业可以由通过 Unix 管道连接的多个子进程组成。

如果命令行以“&”结尾，则作业在后台运行，这意味着 shell 不会等待作业终止就会打印提示符并等待下一个命令行。否则，作业在前台运行，这意味着 shell 会等待作业终止后再等待下一个命令行。因此，在任何时候，最多只能有一个作业在前台运行。然而，任意数量的作业可以在后台运行。
------------------------------------------------------------------------
tsh> jobs
会导致 shell 执行内置的 jobs 命令。输入命令行：
tsh> /bin/ls -l -d
会在前台运行 ls 程序。按照惯例，shell 确保当程序开始执行其主例程时：
int main(int argc, char *argv[])
argc 和 argv 参数具有以下值：

argc == 3,

argv[0] == "/bin/ls",

argv[1] == "-l",

argv[2] == "-d".
------------------------------------------------------------------------
Unix shell 支持作业控制的概念，允许用户在后台和前台之间来回移动作业，并更改作业中进程的状态（运行、停止或终止）。输入 ctrl-c 会向前台作业中的每个进程发送 SIGINT 信号。SIGINT 的默认操作是终止进程。类似地，输入 ctrl-z 会向前台作业中的每个进程发送 SIGTSTP 信号。SIGTSTP 的默认操作是将进程置于停止状态，直到它收到 SIGCONT 信号后被唤醒。Unix shell 还提供了各种支持作业控制的内置命令

jobs：列出正在运行和停止的后台作业。

bg <job>：将停止的后台作业更改为运行的后台作业。

fg <job>：将停止或运行的后台作业更改为前台运行。

kill <job>：终止作业。
------------------------------------------------------------------------
检查你的工作
我们提供了一些工具来帮助你检查你的工作。

参考解决方案。 Linux 可执行文件 tshref 是 shell 的参考解决方案。运行此程序以解决你关于 shell 应如何行为的任何疑问。你的 shell 应产生与参考解决方案相同的输出（当然，PID 会有所不同，因为它们每次运行都会变化）。

Shell 驱动程序。 sdriver.pl 程序将 shell 作为子进程执行，根据跟踪文件的指示向其发送命令和信号，并捕获并显示 shell 的输出。

使用 -h 参数查看 sdriver.pl 的用法：

unix> ./sdriver.pl -h
用法：sdriver.pl [-hv] -t <trace> -s <shellprog> -a <args>
选项：
  -h 打印此消息
  -v 更详细
  -t <trace> 跟踪文件
  -s <shell> 要测试的 shell 程序
  -a <args> shell 参数
  -g 为自动评分生成输出

我们还提供了 16 个跟踪文件（trace{01-16}.txt），你将使用这些文件与 shell 驱动程序一起测试 shell 的正确性。编号较低的跟踪文件执行非常简单的测试，而编号较高的测试执行更复杂的测试。

你可以使用跟踪文件 trace01.txt（例如）运行 shell 驱动程序，输入：
unix> ./sdriver.pl -t trace01.txt -s ./tsh -a "-p"
（-a "-p" 参数告诉你的 shell 不要发出提示符），或者：
unix> make test01

同样，要将你的结果与参考 shell 进行比较，你可以通过输入以下命令在参考 shell 上运行跟踪驱动程序：
unix> ./sdriver.pl -t trace01.txt -s ./tshref -a "-p"
或者：
unix> make rest01
------------------------------------------------------------------------
作为参考，tshref.out 提供了参考解决方案在所有跟踪文件上的输出。这可能比手动在所有跟踪文件上运行 shell 驱动程序更方便。

跟踪文件的一个好处是，它们生成的输出与你交互式运行 shell 时得到的输出相同（除了标识跟踪的初始注释）。例如：

bass> make test15
./sdriver.pl -t trace15.txt -s ./tsh -a "-p"
#
# trace15.txt - 综合测试
#
tsh> ./bogus
./bogus: 命令未找到。
tsh> ./myspin 10
作业 (9721) 被信号 2 终止
tsh> ./myspin 3 &
[1] (9723) ./myspin 3 &
tsh> ./myspin 4 &
[2] (9725) ./myspin 4 &
tsh> jobs
[1] (9723) 正在运行 ./myspin 3 &
[2] (9725) 正在运行 ./myspin 4 &
tsh> fg %1
作业 [1] (9723) 被信号 20 停止
tsh> jobs
[1] (9723) 已停止 ./myspin 3 &
[2] (9725) 正在运行 ./myspin 4 &
tsh> bg %3
%3: 无此作业
tsh> bg %1
[1] (9723) ./myspin 3 &
tsh> jobs
[1] (9723) 正在运行 ./myspin 3 &
[2] (9725) 正在运行 ./myspin 4 &
tsh> fg %1
tsh> quit
bass>
------------------------------------------------------------------------
提示
阅读教科书第8章（异常控制流）的每一个字。

使用跟踪文件来指导你的 shell 开发。从 trace01.txt 开始，确保你的 shell 产生与参考 shell 相同的输出。然后继续处理 trace02.txt，依此类推。

waitpid、kill、fork、execve、setpgid 和 sigprocmask 函数将非常有用。waitpid 的 WUNTRACED 和 WNOHANG 选项也很有用。

当你实现信号处理程序时，确保将 SIGINT 和 SIGTSTP 信号发送到整个前台进程组，使用 -pid 而不是 pid 作为 kill 函数的参数。sdriver.pl 程序会测试此错误。

作业的一个棘手部分是决定 waitfg 和 sigchild_handler 函数之间的工作分配。我们建议采用以下方法：

在 waitfg 中，使用围绕 sleep 函数的忙循环。

在 sigchild_handler 中，仅调用一次 waitpid。

虽然其他解决方案也是可能的，例如在 waitfg 和 sigchild_handler 中都调用 waitpid，但这些方法可能会非常混乱。在处理程序中进行所有回收操作更简单。

在 eval 中，父进程必须在 fork 子进程之前使用 sigprocmask 阻塞 SIGCHLD 信号，然后在调用 addjob 将子进程添加到作业列表后再次使用 sigprocmask 解除阻塞。由于子进程继承了父进程的阻塞向量，子进程必须在执行新程序之前确保解除阻塞 SIGCHLD 信号。

父进程需要以这种方式阻塞 SIGCHLD 信号，以避免竞争条件，即子进程在父进程调用 addjob 之前被 sigchild_handler 回收（从而从作业列表中删除）。

诸如 more、less、vi 和 emacs 等程序会对终端设置进行奇怪的操作。不要从你的 shell 中运行这些程序。坚持使用简单的基于文本的程序，如 /bin/ls、/bin/ps 和 /bin/echo。

当你在标准 Unix shell 中运行你的 shell 时，你的 shell 在前台进程组中运行。如果你的 shell 创建了一个子进程，默认情况下该子进程也将是前台进程组的成员。由于输入 ctrl-c 会向前台组中的每个进程发送 SIGINT 信号，输入 ctrl-c 会向你的 shell 以及你的 shell 创建的每个进程发送 SIGINT 信号，这显然是不正确的。

以下是解决方法：在 fork 之后但在 execve 之前，子进程应调用 setpgid(0, 0)，这将子进程放入一个新的进程组，其组 ID 与子进程的 PID 相同。这确保前台进程组中只有一个进程，即你的 shell。当你输入 ctrl-c 时，shell 应捕获生成的 SIGINT 信号，然后将其转发到适当的前台作业（更准确地说，是包含前台作业的进程组）。
------------------------------------------------------------------------
