------------------------------------------------------------------------
在本实验中，您将学习如何设计和优化流水线化的 Y86-64 处理器，通过优化基准程序和处理器设计来最大化性能。您可以对基准程序进行语义保持的转换，或增强流水线处理器的设计，或两者兼施。完成本实验后，您将深刻理解代码与硬件的交互对程序性能的影响。

实验分为三个部分，每部分需单独提交：

Part A：编写简单的 Y86-64 程序，熟悉工具链。

Part B：扩展 SEQ 模拟器，添加新指令。

Part C：优化 Y86-64 基准程序和处理器设计。
------------------------------------------------------------------------
tar -xvf archlab-handout.tar  
进入 sim 目录并编译工具链：
cd sim  
make clean; make
------------------------------------------------------------------------
Part A:
------------------------------------------------------------------------
任务：
在 sim/misc 目录下编写以下 Y86-64 程序，功能需与示例 C 代码（examples.c）一致：
------------------------------------------------------------------------
(1) sum.ys：迭代求和链表元素
输入：链表头指针 %rdi。
功能：遍历链表，累加节点的值，结果存入 %rax。
example:
.align 8  
ele1: .quad 0x00a, ele2  
ele2: .quad 0x0b0, ele3  
ele3: .quad 0xc00, 0  
预期结果：0x00a + 0x0b0 + 0xc00 = 0xcba


(2) rsum.ys：递归求和链表元素
递归实现需遵循 x86-64 调用约定，保存和恢复被调用者保存寄存器（如 %rbx）。


(3) copy.ys：复制内存块并计算异或校验和
输入：源地址 %rdi，目标地址 %rsi，长度 %rdx。
功能：复制数据到目标地址，返回所有源数据的异或值。
example:
.align 8  
src:  .quad 0x00a, 0x0b0, 0xc00  
dest: .quad 0x111, 0x222, 0x333  
预期结果：0x00a ^ 0x0b0 ^ 0xc00 = 0xcba。
------------------------------------------------------------------------
要求：
函数需正确处理栈帧和寄存器。
使用 YAS 汇编和 YIS 模拟器测试。
------------------------------------------------------------------------
Part B:
------------------------------------------------------------------------
任务：在 sim/seq 目录下修改 seq-full.hcl，添加 iaddq 指令。
------------------------------------------------------------------------
iaddq 指令描述
------------------------------------------------------------------------
格式：iaddq Imm, D
------------------------------------------------------------------------
行为：D ← D + Imm
------------------------------------------------------------------------
阶段分解：
取指：读取立即数 Imm 和寄存器 D。
译码：无需读取其他寄存器。
执行：ALU 执行加法 valD + Imm。
写回：结果写回寄存器 D。
更新 PC：PC ← PC + 10（指令长度）。
------------------------------------------------------------------------
验证步骤：
编译新模拟器
make VERSION=full  
测试 asumi.yo
./ssim -t ../y86-code/asumi.yo  
运行回归测试
(cd ../y86-code; make testssim)  
(cd ../ptest; make SIM=../seq/ssim TFLAGS=-i)  
------------------------------------------------------------------------
Part C:
------------------------------------------------------------------------
任务：在 sim/pipe 目录下优化 ncopy.ys 和 pipe-full.hcl，最小化平均周期数（CPE）。
------------------------------------------------------------------------
基准代码分析:
功能：复制数组并统计正数个数。
初始 CPE：14.24（63 个元素需 897 周期）。
优化目标：平均 CPE < 9.0，最优可达 7.48。
------------------------------------------------------------------------
优化策略:
循环展开：减少分支预测开销
Loop:  
    mrmovq (%rdi), %r10  
    rmmovq %r10, (%rsi)  
    andq %r10, %r10  
    jle Npos  
    iaddq $1, %rax  
Npos:  
    iaddq $8, %rdi  
    iaddq $8, %rsi  
    iaddq $-1, %rdx  
    jg Loop  
使用 iaddq：合并加减操作。
指令重排：避免流水线阻塞，如将加载和使用隔开。
条件传送：替换条件跳转，减少分支误预测。
------------------------------------------------------------------------
验证步骤:
生成测试驱动： make drivers  
模拟运行:
./psim -g sdriver.yo    # 测试小数组  
./psim -g ldriver.yo   # 测试大数组  
性能评估：
./benchmark.pl         # 计算平均 CPE  
./correctness.pl       # 验证功能正确性  
------------------------------------------------------------------------
Part A：提交 sum.ys、rsum.ys、copy.ys。

Part B：提交 seq-full.hcl。

Part C：提交 ncopy.ys 和 pipe-full.hcl。

文件头部需包含姓名、ID和修改说明。
------------------------------------------------------------------------
评分标准：

Part A：每正确一个程序得 10 分。

Part B：描述（10 分）+ 回归测试通过（50 分）。

Part C：描述（20 分）+ 性能（60 分，CPE < 900）。
------------------------------------------------------------------------
提示：

使用 GUI 调试器定位错误。

逐步优化，确保每次修改后功能正确。

参考课本第 4 章和第 5 章（循环展开）。
------------------------------------------------------------------------

